{{>licenseInfo}}
{{#operations}}

#include "{{classname}}.h"

{{#apiNamespaceDeclarations}}
namespace {{this}} {
{{/apiNamespaceDeclarations}}

using namespace {{modelNamespace}};

{{classname}}::{{classname}}(Pistache::Address addr)
    : httpEndpoint(std::make_shared<Pistache::Http::Endpoint>(addr))
{ };

void {{classname}}::init(size_t thr = 2) {
    auto opts = Pistache::Http::Endpoint::options()
        .threads(thr);
    httpEndpoint->init(opts);
    setupRoutes();
}

void {{classname}}::start() {
    httpEndpoint->setHandler(router.handler());
    httpEndpoint->serve();
}

void {{classname}}::shutdown() {
    httpEndpoint->shutdown();
}

void {{classname}}::setupRoutes() {
    using namespace Pistache::Rest;

    {{#operation}}
    Routes::{{httpMethod}}(router, base + "{{{vendorExtensions.x-codegen-pistache-path}}}", Routes::bind(&{{classname}}::{{operationIdSnakeCase}}_handler, this));
    {{/operation}}

    // Default handler, called when a route is not found
    router.addCustomHandler(Routes::bind(&{{classname}}::{{classnameSnakeLowerCase}}_default_handler, this));
}

{{#operation}}
void {{classname}}::{{operationIdSnakeCase}}_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
  try { {{#vendorExtensions.x-codegen-pistache-isParsingSupported}}{{#hasPathParams}}
    // Getting the path params
    {{#pathParams}}
    auto {{paramName}} = request.param(":{{paramName}}").as<{{{dataType}}}>();{{/pathParams}}{{/hasPathParams}}{{#hasBodyParam}}

    // Getting the body param
    {{#bodyParam}}
    {{^isPrimitiveType}}
    {{baseType}} {{paramName}};{{/isPrimitiveType}}
    {{#isPrimitiveType}}
    {{{dataType}}} {{paramName}};
    {{/isPrimitiveType}}{{/bodyParam}}{{/hasBodyParam}}{{#hasQueryParams}}

    // Getting the query params
    {{#queryParams}}
    {{#vendorExtensions.x-is-optional-primitive}}

    // Handle optional primitive parameters
    {{{dataType}}} {{paramName}};
    if (request.query().has("{{baseName}}")) {
      auto sval = request.query().get("{{baseName}}").value();
      try {
        {{#vendorExtensions.x-is-integer}}
        {{paramName}} = std::stoi(sval);
        {{/vendorExtensions.x-is-integer}}
        {{#vendorExtensions.x-is-long}}
        {{paramName}} = std::stoll(sval);
        {{/vendorExtensions.x-is-long}}
        {{#vendorExtensions.x-is-float}}
        {{paramName}} = std::stof(sval);
        {{/vendorExtensions.x-is-float}}
        {{#vendorExtensions.x-is-double}}
        {{paramName}} = std::stod(sval);
        {{/vendorExtensions.x-is-double}}
        {{#vendorExtensions.x-is-boolean}}
        if (sval == "true" || sval == "1") {
          {{paramName}} = true;
        } else if (sval == "false" || sval == "0") {
          {{paramName}} = false;
        } else {
          throw std::runtime_error("Invalid boolean value '" + sval + "' for {{baseName}}");
        }
        {{/vendorExtensions.x-is-boolean}}
      } catch (const std::exception& e) {
        throw std::runtime_error("Error parsing query parameter '{{baseName}}' with value '" + sval + "': " + e.what());
      }
    }
    {{/vendorExtensions.x-is-optional-primitive}}
    {{^vendorExtensions.x-is-optional-primitive}}
    {{^required}}
    auto {{paramName}} = request.query().get("{{baseName}}");
    {{/required}}
    {{#required}}
    auto {{paramName}} = request.query().get("{{baseName}}");{{/required}}{{/vendorExtensions.x-is-optional-primitive}}{{/queryParams}}{{/hasQueryParams}}{{#hasHeaderParams}}

    // Getting the header params
    {{#headerParams}}
    auto {{paramName}} = request.headers().tryGetRaw("{{baseName}}");{{/headerParams}}{{/hasHeaderParams}}{{#hasBodyParam}}{{#bodyParam}}
    nlohmann::json request_body = nlohmann::json::parse(request.body());
    {{^isPrimitiveType}}
    {{paramName}}.fromJson(request_body);{{/isPrimitiveType}}
    {{#isPrimitiveType}}
    {{paramName}} = request_body;
    {{/isPrimitiveType}}{{/bodyParam}}{{/hasBodyParam}}
    this->{{operationIdSnakeCase}}({{#allParams}}{{paramName}}{{#hasMore}}, {{/hasMore}}{{/allParams}}{{#hasParams}}, {{/hasParams}}response);
    {{/vendorExtensions.x-codegen-pistache-isParsingSupported}}
    {{^vendorExtensions.x-codegen-pistache-isParsingSupported}}
    this->{{operationIdSnakeCase}}(request, response);
    {{/vendorExtensions.x-codegen-pistache-isParsingSupported}}
  } catch (std::runtime_error & e) {
    //send a 400 error
    response.send(Pistache::Http::Code::Bad_Request, e.what());
    return;
  }
}

{{/operation}}
void {{classname}}::{{classnameSnakeLowerCase}}_default_handler(const Pistache::Rest::Request &request, Pistache::Http::ResponseWriter response) {
    response.send(Pistache::Http::Code::Not_Found, "The requested method does not exist");
}

{{#apiNamespaceDeclarations}}
}
{{/apiNamespaceDeclarations}}

{{/operations}}
